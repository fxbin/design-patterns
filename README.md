# design patterns

## TODO

### 创建型模式
 - [ ] 简单工厂模式
 - [ ] 工厂方法模式
 - [ ] 抽象工厂模式
 - [ ] 建造者模式
 - [ ] 原型模式
 - [ ] 单例模式
### 行为型模式
 - [X] 责任链模式
 - [ ] 命令模式
 - [ ] 解释器模式
 - [ ] 迭代器模式
 - [ ] 中介者模式
 - [ ] 备忘录模式
 - [ ] 观察者模式
 - [ ] 状态模式
 - [X] 策略模式
 - [ ] 模板方法模式
 - [ ] 访问者模式
 - [ ] 委派模式
### 结构型模式
 - [ ] 适配器模式
 - [ ] 桥接模式
 - [ ] 组合模式
 - [ ] 装饰模式
 - [ ] 外观模式
 - [ ] 享元模式
 - [ ] 代理模式



## 责任链设计模式

### 是什么

* 客户端发出一个请求，链上的对象都有机会来处理这一请求，而客户端不需要知道谁是具体的处理对象。
* 多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。
* 将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。其过程实际上是一个递归调用。

> 总结：
 
 * 有多个对象共同对一个任务进行处理。
 * 这些对象使用链式存储结构，形成一个链，每个对象知道自己的下一个对象。
 * 一个对象对任务进行处理，可以添加一些操作后将对象传递个下一个任务。也可以在此对象上结束任务的处理，并结束任务。
 * 客户端负责组装链式结构，但是客户端不需要关心最终是谁来处理了任务。
 
 ### 应用场景
 
 * 多条件流程判断：权限控制
 * ERP 系统流程审批：总经理、人事经理、项目经理
 * Java 过滤器的底层实现 Filter
 
> 总结： 
> 1、如果一个逻辑是按照一定的步骤进行的，而步骤之间存在复杂的逻辑计算，那么可以考虑使用责任链设计模式; 
> 2、或者一坨if分支时，也可以考虑使用责任链设计模式
 
 ### 责任链模式的优缺点
 
 #### 优点
 
 * 动态组合，使请求者和接受者解耦。
 * 请求者和接受者松散耦合：请求者不需要知道接受者，也不需要知道如何处理。每个职责对象只负责自己的职责范围，其他的交给后继者。各个组件间完全解耦。
 * 动态组合职责：职责链模式会把功能分散到单独的职责对象中，然后在使用时动态的组合形成链，从而可以灵活的分配职责对象，也可以灵活的添加改变对象职责。
 
 #### 缺点
 
 * 产生很多细粒度的对象：因为功能处理都分散到了单独的职责对象中，每个对象功能单一，要把整个流程处理完，需要很多的职责对象，会产生大量的细粒度职责对象。
 * 不一定能处理：每个职责对象都只负责自己的部分，这样就可以出现某个请求，即使把整个链走完，都没有职责对象处理它。这就需要提供默认处理，并且注意构造链的有效性。
 
 ### 责任链总结
 
 * 首先定义一个抽象类，该抽象类定义了请求处理方法和持有对自己的引用（接收下一个处理者）
 * 继承上面的抽象类，定义具体的请求处理者
 * 设置处理请求链，处理请求链，可以在代码中写死，也可以通过存储在数据库中再读取出来。
 
 ## 策略模式
 
 ### 定义
 
 > 策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理，最终可以解决多重 if 判断问题。
 
 ### 结构
 
 * 环境（Context）角色：持有一个 Strategy 的引用。
 * 抽象策略（Strategy）角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色 给出所有的具体策略类所需的接口。
 * 具体策略（ConcreteStrategy）角色：包装了相关的算法或行为。
 
 ### 架构图
 
 ![img 策略模式架构图](images/策略模式架构图.jpg)
 
 ### 策略模式优缺点
 
 #### 优点
 
 * 算法可以自由切换（高层屏蔽算法，角色自由切换）
 * 避免使用多重条件判断（如果算法过多就会出现很多种相同的判断，很难维护）
 * 扩展性好（可自由添加取消算法而不影响整个功能）
 
 #### 缺点
 
 * 策略类数量增多（每一个策略类复用性很小，如果需要增加算法，就只能新增类）
 * 所有的策略类都需要对外暴露（使用的人必须了解使用策略，这个就需要其它模式来补充，比如工厂模式、代理模式）
 
 ### 策略模式应用场景
 
 > 策略模式的应用场景很多，比如商场的促销活动、联合登录（qq、微信）、聚合支付（微信支付、支付宝支付）等。
 
 
 