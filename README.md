# design patterns

## 责任链设计模式

### 是什么

* 客户端发出一个请求，链上的对象都有机会来处理这一请求，而客户端不需要知道谁是具体的处理对象。
* 多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。
* 将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。其过程实际上是一个递归调用。

> 总结：
 
 * 有多个对象共同对一个任务进行处理。
 * 这些对象使用链式存储结构，形成一个链，每个对象知道自己的下一个对象。
 * 一个对象对任务进行处理，可以添加一些操作后将对象传递个下一个任务。也可以在此对象上结束任务的处理，并结束任务。
 * 客户端负责组装链式结构，但是客户端不需要关心最终是谁来处理了任务。
 
 ### 应用场景
 
 * 多条件流程判断：权限控制
 * ERP 系统流程审批：总经理、人事经理、项目经理
 * Java 过滤器的底层实现 Filter
 
> 总结： 
> 1、如果一个逻辑是按照一定的步骤进行的，而步骤之间存在复杂的逻辑计算，那么可以考虑使用责任链设计模式; 
> 2、或者一坨if分支时，也可以考虑使用责任链设计模式
 
 ### 责任链模式的优缺点
 
 #### 优点
 
 * 动态组合，使请求者和接受者解耦。
 * 请求者和接受者松散耦合：请求者不需要知道接受者，也不需要知道如何处理。每个职责对象只负责自己的职责范围，其他的交给后继者。各个组件间完全解耦。
 * 动态组合职责：职责链模式会把功能分散到单独的职责对象中，然后在使用时动态的组合形成链，从而可以灵活的分配职责对象，也可以灵活的添加改变对象职责。
 
 #### 缺点
 
 * 产生很多细粒度的对象：因为功能处理都分散到了单独的职责对象中，每个对象功能单一，要把整个流程处理完，需要很多的职责对象，会产生大量的细粒度职责对象。
 * 不一定能处理：每个职责对象都只负责自己的部分，这样就可以出现某个请求，即使把整个链走完，都没有职责对象处理它。这就需要提供默认处理，并且注意构造链的有效性。
 
 ### 责任链总结
 
 * 首先定义一个抽象类，该抽象类定义了请求处理方法和持有对自己的引用（接收下一个处理者）
 * 继承上面的抽象类，定义具体的请求处理者
 * 设置处理请求链，处理请求链，可以在代码中写死，也可以通过存储在数据库中再读取出来。